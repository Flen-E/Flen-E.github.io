---
layout: post
title:  "[SQLD] 자잘한 SQLD 실수 모음"
date:   2024-02-19 19:20:00 -0500
excerpt: "내가 틀린 SQL 문제를 다시 복습해보자"
tags: SQLD
category : [ SQLD ]
---

제목을 정하여 설명 하기 어려운 것들은 이곳에 하나씩 모아 수정하며 추가하도록 하겠다.  
너무 간단한 문제도 있지만 한번 더 확인해서 나쁠 것은 없다고 본다.

---

### 노랭이 과목2 p39 15번문제

REPLACE(A, B, C) => A에 있는 B를 C로 치환.
REPLACE(C1, CHR(10)) => TAB(줄바꿈)을 제거 해준다.

---

### 노랭이 과목2 P49 29번문제

SELECTT 지역, 매출금액  
FROM 지역별매출  
GROUP BY 지역  
ORDER BY 년 DESC;

여기서의 문제점은 GROUP BY로 지역을 그룹핑했는데 ORDER BY로 년을 정렬하고 있는 것이 문제이다.

GROUP BY 절에 명시되지 않은 컬럼은 다른절에 집계함수와 같이 사용하는 것 제외하고는 사용 할 수 없다.

고로 위에 예시는 에러남.  

---

### 노랭이 과목2 P38 13번문제


1. WHERE '201501' = TO_CHAR(SVC_END_DATE, 'YYYYMM'):  
 이 조건은 문자열 '201501'과 SVC_END_DATE의 'YYYYMM' 형식으로 변환된 문자열을 비교합니다.  
 즉, SVC_END_DATE의 월과 연도가   '201501'과 동일한지를 확인합니다.  
  이 경우 SVC_END_DATE가 '2015년 1월'에 끝나는 경우에 해당 조건이 참(True)이 됩니다.  



2. WHERE TO_DATE('201501', 'YYYYMM') = SVC_END_DATE:  
 이 조건은 문자열 '201501'을 날짜로 변환한 후 SVC_END_DATE와 비교합니다.  
  따라서 '201501'은 'YYYYMM' 형식에 따라 '2015년 1월 1일'로 해석됩니다.  
   따라서 SVC_END_DATE가 '2015년 1월 1일'인 경우에만 해당 조건이 참(True)이 됩니다.  


1번은 연도 월만 비교하기때문에 1월 1일부터 31일까지 TRUE  

2번은 201501을 DATE로 바꾸어 2015년 1월 1일이 되었기에 1월 1일인 것만 TRUE


### 노랭이 과목1 p24 41번문제

정규화는 `논리 데이터` 모델의 일관성을 확보하고 중복을 제거하여 속성들이  
가장 적절한 엔터티에 배치되도록 한다.

### 노랭이 과목1 p5 5번문제

#### 데이터 독립성의 구성요소에 대한 설명

- 통합된 모든 사용자의 관점은 `개념스키마`와 관련있다.
- 물리적인 저장구조를 표현하는 스키마는 `내부스키마`이다.
- View 단계는 여러 사용자 관점으로 구성하는 `외부스키마`에 해당한다.
- 논리적인 데이터 독립성을 고려하는 단계는 외부단계와 개념적단계이다.


### 노랭이 과목2 P68 55번문제

SQL문 비교

아래의 SQL 실행 결과가 동일한 SQL은?

### 서비스 테이블

<a href="https://imgbb.com/"><img src="https://i.ibb.co/yd6pQB5/1.png" alt="1" border="0"></a>


### 서비스이용 테이블

<a href="https://imgbb.com/"><img src="https://i.ibb.co/qW42DhY/2.png" alt="2" border="0"></a>

예시를 보여주기 위해 테이블을 만들어 왔다 서비스와 서비스이용은 1:N 관계.  

여기서 보기는
```
SELECT A.서비스ID, B.서비스명, B.서비스URL
FROM (SELECT 서비스ID FROM 서비스
            INTERSECT
            SELECT 서비스ID
            FROM 서비스이용) A, 서비스 B
WHERE A.서비스ID = B.서비스ID;
```
으로 서비스이용중인 서비스ID를 가져오고 B테이블을 서비스이용이 아닌 서비스와 묶어서  
서비스 이용을 하고 있는 서비스를 단독적으로 가져오고있다.  

### 결과

<a href="https://imgbb.com/"><img src="https://i.ibb.co/yd6pQB5/1.png" alt="1" border="0"></a>

이런식으로 결과가 나오게 된다.

하지만 내가 헷갈려서 틀린 1번을 보면

```
SELECT B.서비스ID, A.서비스명, A.서비스URL
  FROM 서비스 A, 서비스이용 B
  WHERE A.서비스ID = B.서비스ID
```

서비스 A와 서비스이용 B를 조인하여 ID가 같은 것을 출력하기에 서비스이용 테이브르이 서비스ID가 모두 출력 될것이다.  

### 결과

<a href="https://imgbb.com/"><img src="https://i.ibb.co/7zh5gfz/3.png" alt="3" border="0"></a>

생각해보면 매우 간단한 문제였지만,  
대충 읽고 푼다면 놓치기 좋은 문제일 것 같아 이곳에 적어둔다.    
2번(정답)을 제외한 나머지 보기는 아얘 틀렸기에 생략.  

### 47회 단답형 6번

#### TAB1

|COL1| COL2|
|-----|-----|
|1 |   NULL|
|2  |  NULL|
|3|    1|
|4 |   1|
|5   | 2|
|6   | 2|
|7  |  3|
|8 |   4|
|9|    5|

```
[SQL]
SELECT COUNT(*)
  FROM TAB1
  WHERE COL1 <> 4
  START WITH COL1= 1
  CONNECT BY PRIOR COL1 = COL2;
```

정답은 3이 아닌 4이다 1 3 7 4 8에서 WHERE절에 의해 4를 제외해서 4개.  

START WITH 절·CONNECT BY 절을 처리 한 후에 WHERE 절을 처리하자!